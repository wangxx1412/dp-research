这是一个非常硬核且现代的架构演进。把 JWT 作为 SFTP 的“密码”传入，代表你们正在实现 Token Exchange（令牌交换） 模式。
在这种模式下：
 * 用户在 SFTP 客户端的 Password 框里粘贴 JWT。
 * AWS Transfer Family 把这串 JWT 放在 HTTP Header 的 Password 字段传给你的 API Gateway。
 * 你的 Lambda 提取 JWT，去 OAuth Server 换取 access_token。
 * 【核心变更】 Lambda 同时拿着 access_token 和原始的 JWT 去请求 App，获取 S3 的 IAM Role。
我为你整理了完整的代码清单（从 Lambda 入口到核心逻辑）。
1. 数据传输模型 (DTOs)
使用 Java record 定义与外部交互的数据结构。
package com.example.sftp.dto;

import com.fasterxml.jackson.annotation.JsonProperty;

// OAuth 换取到的 Access Token
public record AppTokenResponse(
    @JsonProperty("access_token") String accessToken, 
    @JsonProperty("token_type") String tokenType
) {}

// App 返回的 S3 权限配置
public record AppUserSftpConfig(
    @JsonProperty("iam_role_arn") String iamRoleArn,
    @JsonProperty("s3_bucket_path") String s3BucketPath,
    @JsonProperty("scope_down_policy") String scopeDownPolicy
) {}

2. 同步网络客户端配置 (RestClientConfig)
针对 Lambda 环境优化过的轻量级 HTTP Client。
package com.example.sftp.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.JdkClientHttpRequestFactory;
import org.springframework.web.client.RestClient;

import java.net.http.HttpClient;
import java.time.Duration;

@Configuration
public class RestClientConfig {

    @Value("${app.api.base-url}")
    private String apiBaseUrl;

    @Bean
    public RestClient appRestClient() {
        HttpClient nativeClient = HttpClient.newBuilder()
                .connectTimeout(Duration.ofSeconds(5))
                .build();

        JdkClientHttpRequestFactory requestFactory = new JdkClientHttpRequestFactory(nativeClient);
        requestFactory.setReadTimeout(Duration.ofSeconds(10));

        return RestClient.builder()
                .baseUrl(apiBaseUrl)
                .requestFactory(requestFactory)
                .defaultHeader("Accept", "application/json")
                .build();
    }
}

3. 核心业务逻辑 (SftpAdapterService)
这里处理了你要求的 “用 JWT 换 Access Token，然后带着两个 Token 去 App” 的逻辑。
package com.example.sftp.service;

import com.example.sftp.dto.AppTokenResponse;
import com.example.sftp.dto.AppUserSftpConfig;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestClient;
import org.springframework.web.client.RestClientResponseException;

import java.util.HashMap;
import java.util.Map;

@Service
public class SftpAdapterService {

    private final RestClient appRestClient;

    public SftpAdapterService(RestClient appRestClient) {
        this.appRestClient = appRestClient;
    }

    public Map<String, Object> processLogin(String username, String jwtToken) {
        try {
            // --- Step 1: 用用户的 JWT 去换取内部 Access Token ---
            // [CUSTOM] 这里的 grant_type 通常是 jwt-bearer 或者 token-exchange，取决于你的 OAuth Server
            AppTokenResponse tokenResp = appRestClient.post()
                    .uri("/oauth/token")
                    .contentType(MediaType.APPLICATION_FORM_URLENCODED) // 很多 OAuth 要求 Form 格式
                    .body("grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer" +
                          "&assertion=" + jwtToken + 
                          "&scope=sftp.config.read")
                    .retrieve()
                    .body(AppTokenResponse.class);

            if (tokenResp == null || tokenResp.accessToken() == null) {
                throw new RuntimeException("Token exchange failed");
            }

            // --- Step 2: 带着两个 Token 去 App 获取 IAM 权限 ---
            AppUserSftpConfig userConfig = appRestClient.get()
                    .uri("/api/user/sftp-config")
                    // 1. 标准的 Bearer Token 用于通过 App 的 API Gateway/安全拦截器
                    .header("Authorization", "Bearer " + tokenResp.accessToken())
                    // 2. [CUSTOM] 把原始的 JWT 放在自定义 Header 里传给 App
                    .header("X-Original-User-JWT", jwtToken) 
                    .retrieve()
                    .body(AppUserSftpConfig.class);

            if (userConfig == null) {
                throw new RuntimeException("App returned empty configuration");
            }

            // --- Step 3: 组装返回给 AWS Transfer Family 的契约 ---
            return buildAwsResponse(userConfig);

        } catch (RestClientResponseException e) {
            System.err.println("API Call Failed. Status: " + e.getStatusCode() + " Body: " + e.getResponseBodyAsString());
            throw new RuntimeException("Adapter failed", e);
        }
    }

    private Map<String, Object> buildAwsResponse(AppUserSftpConfig config) {
        Map<String, Object> response = new HashMap<>();
        response.put("Role", config.iamRoleArn());
        
        if (config.scopeDownPolicy() != null) {
            response.put("Policy", config.scopeDownPolicy());
        }

        response.put("HomeDirectoryType", "LOGICAL");
        response.put("HomeDirectoryDetails", 
            String.format("[{\"Entry\": \"/\", \"Target\": \"%s\"}]", config.s3BucketPath()));

        return response;
    }
}

4. API 接口层 (Controller)
这里是 API Gateway 路由过来的地方。注意，AWS 传过来的凭据依然在 Password Header 里，只是内容变成了 JWT。
package com.example.sftp.controller;

import com.example.sftp.service.SftpAdapterService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/api/v1/transfer")
public class TransferIdpController {

    private final SftpAdapterService adapterService;

    public TransferIdpController(SftpAdapterService adapterService) {
        this.adapterService = adapterService;
    }

    @GetMapping("/auth")
    public ResponseEntity<Map<String, Object>> handleAuth(
            @RequestParam("username") String username,
            // [IMPORTANT] 用户在 SFTP 客户端输入的 JWT 会被 AWS 塞进这个 Password Header 里
            @RequestHeader(value = "Password", required = false) String jwtToken) {

        if (username == null || jwtToken == null || jwtToken.isEmpty()) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
        }

        try {
            Map<String, Object> awsResponse = adapterService.processLogin(username, jwtToken);
            return ResponseEntity.ok(awsResponse);
        } catch (Exception e) {
            System.err.println("SFTP Auth Failed for user: " + username + ", Error: " + e.getMessage());
            // 失败必须返回 403，AWS Transfer 才会拒绝用户连接
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build(); 
        }
    }
}

5. Lambda 原生入口 (StreamLambdaHandler)
千万别忘了这一步！ 虽然你写了 Spring Boot 的 @RestController，但 AWS Lambda 原生并不认识 Spring 容器。你需要一个“桥梁”把 API Gateway 的事件（Event）转化为 Spring 的 HTTP Request。
需要引入依赖：
<dependency>
    <groupId>com.amazonaws.serverless</groupId>
    <artifactId>aws-serverless-java-container-springboot3</artifactId>
    <version>2.0.0</version> </dependency>

创建 Lambda Handler 类：
package com.example.sftp;

import com.amazonaws.serverless.exceptions.ContainerInitializationException;
import com.amazonaws.serverless.proxy.model.AwsProxyRequest;
import com.amazonaws.serverless.proxy.model.AwsProxyResponse;
import com.amazonaws.serverless.proxy.spring.SpringBootLambdaContainerHandler;
import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestStreamHandler;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

// 这个类就是你在 AWS Lambda 控制台上配置的 "Handler" 路径
// 例如：com.example.sftp.StreamLambdaHandler::handleRequest
public class StreamLambdaHandler implements RequestStreamHandler {

    private static SpringBootLambdaContainerHandler<AwsProxyRequest, AwsProxyResponse> handler;

    static {
        try {
            // 初始化 Spring Boot 上下文（冷启动时触发）
            handler = SpringBootLambdaContainerHandler.getAwsProxyHandler(SftpApplication.class);
        } catch (ContainerInitializationException e) {
            e.printStackTrace();
            throw new RuntimeException("Could not initialize Spring Boot application", e);
        }
    }

    @Override
    public void handleRequest(InputStream inputStream, OutputStream outputStream, Context context)
            throws IOException {
        // 将 AWS API Gateway 的请求代理给 Spring 的 Controller
        handler.proxyStream(inputStream, outputStream, context);
    }
}

设计总结与提醒
 * OAuth 授权模式变更： 由于传入的是 JWT 而不是明文密码，你的 grant_type 不能再用 password。我改成了标准的 urn:ietf:params:oauth:grant-type:jwt-bearer。请确保你的 OAuth Server 支持这种 Token 交换模式。
 * 双 Token 传递： 在 SftpAdapterService 中，我用标准的 Authorization: Bearer <access_token> 发送新换取的 Token，同时加了一个自定义的 X-Original-User-JWT 传入原始 JWT。后端 App 可以从 Header 里读取这两个值进行双重校验。
 * Lambda 冷启动： 既然用了完整的 Spring Boot 容器打包进 Lambda，记得给这个 Lambda 分配至少 1024 MB 的内存，否则冷启动时间可能会超过 10 秒，导致 SFTP 客户端超时断开。



太棒了，使用强类型的 DTO（AuthResponse）替代原生的 Map<String, Object> 是非常好的工程实践！这样代码不仅更清晰，还能利用 Jackson 的注解来严格控制输出的 JSON 格式。
我们需要对代码做三处修改：定义 AuthResponse、更新 Service 返回值、更新 Controller 返回值。
1. 新增 AuthResponse DTO
AWS Transfer Family 对返回的 JSON 字段名大小写敏感，所以我们必须使用 @JsonProperty 来强制首字母大写。同时，如果 Policy 为空，最好不要在 JSON 里输出这个字段，所以加上 @JsonInclude(JsonInclude.Include.NON_NULL)。
package com.example.sftp.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

// 让 Jackson 在序列化时忽略值为 null 的字段
@JsonInclude(JsonInclude.Include.NON_NULL)
public record AuthResponse(
    
    // 必填：AWS IAM Role ARN
    @JsonProperty("Role") 
    String role,

    // 选填：Scope-down Policy (转义后的 JSON 字符串)
    @JsonProperty("Policy") 
    String policy,

    // 选填：通常写死为 "LOGICAL"
    @JsonProperty("HomeDirectoryType") 
    String homeDirectoryType,

    // 选填：逻辑目录映射数组 (转义后的 JSON 字符串)
    @JsonProperty("HomeDirectoryDetails") 
    String homeDirectoryDetails
) {}

2. 更新核心逻辑 (SftpAdapterService)
现在我们可以直接删掉那个繁琐的 buildAwsResponse 方法，并在拿到 AppUserSftpConfig 后直接构造并返回 AuthResponse。
package com.example.sftp.service;

import com.example.sftp.dto.AppTokenResponse;
import com.example.sftp.dto.AppUserSftpConfig;
import com.example.sftp.dto.AuthResponse; // 引入你新的 DTO
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestClient;
import org.springframework.web.client.RestClientResponseException;

@Service
public class SftpAdapterService {

    private final RestClient appRestClient;

    public SftpAdapterService(RestClient appRestClient) {
        this.appRestClient = appRestClient;
    }

    // 返回类型改成了 AuthResponse
    public AuthResponse processLogin(String username, String jwtToken) {
        try {
            // --- Step 1: JWT 换取 Access Token ---
            AppTokenResponse tokenResp = appRestClient.post()
                    .uri("/oauth/token")
                    .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                    .body("grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer" +
                          "&assertion=" + jwtToken + 
                          "&scope=sftp.config.read")
                    .retrieve()
                    .body(AppTokenResponse.class);

            if (tokenResp == null || tokenResp.accessToken() == null) {
                throw new RuntimeException("Token exchange failed");
            }

            // --- Step 2: 获取 IAM 权限配置 ---
            AppUserSftpConfig userConfig = appRestClient.get()
                    .uri("/api/user/sftp-config")
                    .header("Authorization", "Bearer " + tokenResp.accessToken())
                    .header("X-Original-User-JWT", jwtToken) 
                    .retrieve()
                    .body(AppUserSftpConfig.class);

            if (userConfig == null) {
                throw new RuntimeException("App returned empty configuration");
            }

            // --- Step 3: 直接构造并返回强类型的 AuthResponse ---
            String logicalDetails = String.format("[{\"Entry\": \"/\", \"Target\": \"%s\"}]", userConfig.s3BucketPath());
            
            return new AuthResponse(
                userConfig.iamRoleArn(),
                userConfig.scopeDownPolicy(), // 如果为 null，Jackson 会自动忽略它
                "LOGICAL",
                logicalDetails
            );

        } catch (RestClientResponseException e) {
            System.err.println("API Call Failed. Status: " + e.getStatusCode() + " Body: " + e.getResponseBodyAsString());
            throw new RuntimeException("Adapter failed", e);
        }
    }
}

3. 更新接口层 (TransferIdpController)
同样地，把 Controller 的泛型从 Map<String, Object> 改成 AuthResponse。
package com.example.sftp.controller;

import com.example.sftp.dto.AuthResponse; // 引入 DTO
import com.example.sftp.service.SftpAdapterService;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/v1/transfer")
public class TransferIdpController {

    private final SftpAdapterService adapterService;

    public TransferIdpController(SftpAdapterService adapterService) {
        this.adapterService = adapterService;
    }

    @GetMapping("/auth")
    // 返回类型改成 ResponseEntity<AuthResponse>
    public ResponseEntity<AuthResponse> handleAuth(
            @RequestParam("username") String username,
            @RequestHeader(value = "Password", required = false) String jwtToken) {

        if (username == null || jwtToken == null || jwtToken.isEmpty()) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
        }

        try {
            // 直接接收 AuthResponse
            AuthResponse awsResponse = adapterService.processLogin(username, jwtToken);
            return ResponseEntity.ok(awsResponse);
        } catch (Exception e) {
            System.err.println("SFTP Auth Failed for user: " + username + ", Error: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.FORBIDDEN).build(); 
        }
    }
}

改进的好处总结：
 * 类型安全 (Type Safety): 编译期就能发现拼写错误（比如以前写 response.put("role", ...) 小写了 r，编译不会报错，但 AWS 会拒绝连接）。
 * 空值处理更优雅: 利用 @JsonInclude(JsonInclude.Include.NON_NULL) 完美处理了 Policy 字段可能不存在的情况，代码不用再写 if (policy != null) 的判断逻辑。
 * 代码行数更少: DTO 模式天然去掉了拼装 Map 的繁琐代码。
