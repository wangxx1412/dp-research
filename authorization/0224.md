这是一个极其明智的架构演进！抛弃 Spring Boot 容器，改用 原生 AWS Lambda Handler (Native Lambda)，这意味着你彻底告别了 Java 冷启动的噩梦（从 5-10 秒缩短到 200-500 毫秒）。同时，采用纯正的 Token Exchange (令牌交换) 模式来对接 DaaS (Data as a Service) 平台，非常符合现代企业级零信任架构。
既然请求可能来自不同的 Service（多租户/多服务接入），我们的 Scope 设计和 Lambda 代码都需要围绕 “上下文透传” 和 “轻量化” 来重构。
一、 重新设计：多服务场景下的 Scope 与 API 映射
在多服务场景下，Lambda 是一个“中继站（Delegator）”。它不需要知道具体的业务，只需要负责把 Token 换出来，丢给 DaaS App 去做裁决。
1. Scope 设计方案 (Scope Design)
我们需要将 Scope 分为两层：基础通信 Scope 和 服务数据 Scope。
| Scope 名称 | 颁发给谁 | 作用描述 | 对应验证 API |
|---|---|---|---|
| daas:sftp:exchange | Lambda 本身 | 基础通信 Scope： 允许 Lambda 调用 Auth Server 的 Token 交换接口。 | Auth Server: POST /oauth/token |
| finance:data:read | 财务 Service | 服务数据 Scope： 允许读取财务相关 DaaS 数据。 | DaaS App: GET /api/v1/daas/sftp/role |
| marketing:data:write | 营销 Service | 服务数据 Scope： 允许写入营销相关 DaaS 数据。 | DaaS App: GET /api/v1/daas/sftp/role |
2. 交互流程与 API 详情实例 (Step-by-Step Example)
假设 财务服务 (Finance Service) 想要通过 SFTP 接入 DaaS 获取数据。
 * 前提： 财务服务自己生成了一个 JWT（或者从 Auth Server 获取了一个初始 JWT），这个 JWT 里面的 sub 是 finance-service-account。
 * 动作： 财务服务使用该 JWT 作为密码连接 SFTP。
Step 1: Lambda -> Auth Server (Token Exchange)
 * 请求 API: POST /oauth/token
 * 参数: Lambda 发送 grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer，assertion=<Finance_JWT>，以及 scope=daas:sftp:exchange。
 * Auth Server 响应: Auth Server 验证 JWT 是财务服务发来的，根据策略，返回一个包含了财务专属 Scope 的 Access Token：
   {
  "access_token": "eyJhbG...",
  "grant_type": "urn:ietf:params:oauth:grant-type:jwt-bearer",
  "expires_in": 3600,
  "scope": "finance:data:read daas:sftp:exchange" 
}

Step 2: Lambda -> DaaS App (获取角色)
 * 请求 API: GET /api/v1/daas/sftp/role?username=finance-job-1
 * Headers: Authorization: Bearer <access_token>
 * DaaS App 处理: DaaS 解析 Access Token，看到 finance:data:read，决定下发财务专属的 IAM Role 和对应 S3 桶路径。
二、 Native Lambda 代码实现 (纯 Java，无 Spring)
为了保持极致的启动速度，我们将使用 Java 11+ 内置的 java.net.http.HttpClient 和轻量级的 Jackson 库。
1. Maven 依赖 (pom.xml)
你只需要 AWS Lambda 核心包和 Jackson。
<dependencies>
    <dependency>
        <groupId>com.amazonaws</groupId>
        <artifactId>aws-lambda-java-core</artifactId>
        <version>1.2.2</version>
    </dependency>
    <dependency>
        <groupId>com.amazonaws</groupId>
        <artifactId>aws-lambda-java-events</artifactId>
        <version>3.11.1</version>
    </dependency>
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
        <version>2.15.2</version>
    </dependency>
</dependencies>

2. 核心 Lambda Handler (SftpNativeHandler.java)
package com.example.sftp;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyRequestEvent;
import com.amazonaws.services.lambda.runtime.events.APIGatewayProxyResponseEvent;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.HashMap;
import java.util.Map;

// 实现 AWS 原生 RequestHandler 接口
public class SftpNativeHandler implements RequestHandler<APIGatewayProxyRequestEvent, APIGatewayProxyResponseEvent> {

    // [PLACEHOLDER] 环境变量配置
    private static final String AUTH_SERVER_URL = System.getenv("AUTH_SERVER_URL"); // e.g., https://auth.com/oauth/token
    private static final String DAAS_APP_URL = System.getenv("DAAS_APP_URL");       // e.g., https://daas.com/api/v1/daas/sftp/role
    
    // 复用 HttpClient 和 ObjectMapper 避免每次请求重复初始化，提升性能
    private static final HttpClient httpClient = HttpClient.newBuilder()
            .connectTimeout(Duration.ofSeconds(3))
            .build();
    private static final ObjectMapper objectMapper = new ObjectMapper()
            .setSerializationInclusion(JsonInclude.Include.NON_NULL);

    @Override
    public APIGatewayProxyResponseEvent handleRequest(APIGatewayProxyRequestEvent event, Context context) {
        // AWS Lambda 提供的标准日志记录器
        var logger = context.getLogger();
        
        try {
            // 1. 从 API Gateway 事件中提取参数
            Map<String, String> headers = event.getHeaders();
            Map<String, String> queryParams = event.getQueryStringParameters();

            // API Gateway 传进来的 Header 可能是小写，保险起见都转小写取值
            String jwtToken = getHeaderIgnoreCase(headers, "password"); 
            String username = queryParams != null ? queryParams.get("username") : "unknown";
            
            if (jwtToken == null || jwtToken.isEmpty()) {
                logger.log("Missing JWT Token in Password header for user: " + username);
                return createForbiddenResponse();
            }

            // --- Step 1: Lambda -> Auth Server (Token Exchange) ---
            logger.log("Step 1: Exchanging JWT for Access Token. User: " + username);
            
            // [CUSTOM] 构造符合 OAuth Token Exchange 规范的 body
            String authBody = "grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer" +
                              "&assertion=" + jwtToken +
                              "&scope=daas:sftp:exchange";

            HttpRequest authRequest = HttpRequest.newBuilder()
                    .uri(URI.create(AUTH_SERVER_URL))
                    .timeout(Duration.ofSeconds(5))
                    .header("Content-Type", "application/x-www-form-urlencoded")
                    .POST(HttpRequest.BodyPublishers.ofString(authBody))
                    .build();

            HttpResponse<String> authResponse = httpClient.send(authRequest, HttpResponse.BodyHandlers.ofString());
            
            if (authResponse.statusCode() != 200) {
                logger.log("Auth Server rejected token exchange. Status: " + authResponse.statusCode() + " Body: " + authResponse.body());
                return createForbiddenResponse();
            }

            // 解析 Auth Server 返回的 JSON (包含 scope, grant_type, access_token, expires_in)
            JsonNode authJson = objectMapper.readTree(authResponse.body());
            String accessToken = authJson.get("access_token").asText();


            // --- Step 2: Lambda -> DaaS App (获取 S3 权限配置) ---
            logger.log("Step 2: Requesting DaaS role with Access Token...");
            
            // [CUSTOM] 调用 DaaS 接口，可以把 username 传过去方便审计
            HttpRequest daasRequest = HttpRequest.newBuilder()
                    .uri(URI.create(DAAS_APP_URL + "?username=" + username))
                    .timeout(Duration.ofSeconds(5))
                    .header("Authorization", "Bearer " + accessToken)
                    .GET()
                    .build();

            HttpResponse<String> daasResponse = httpClient.send(daasRequest, HttpResponse.BodyHandlers.ofString());

            if (daasResponse.statusCode() != 200) {
                logger.log("DaaS App rejected access. Status: " + daasResponse.statusCode() + " Body: " + daasResponse.body());
                return createForbiddenResponse();
            }

            // 解析 DaaS 返回的数据
            JsonNode daasJson = objectMapper.readTree(daasResponse.body());
            
            // --- Step 3: 组装返回给 AWS Transfer Family 的 JSON ---
            Map<String, Object> awsTransferResponse = new HashMap<>();
            awsTransferResponse.put("Role", daasJson.get("iamRoleArn").asText());
            
            if (daasJson.has("scopeDownPolicy")) {
                awsTransferResponse.put("Policy", daasJson.get("scopeDownPolicy").asText());
            }

            // 强制转换为 AWS 的逻辑目录格式
            String s3Path = daasJson.get("s3BucketPath").asText();
            String logicalDetails = String.format("[{\"Entry\": \"/\", \"Target\": \"%s\"}]", s3Path);
            awsTransferResponse.put("HomeDirectoryType", "LOGICAL");
            awsTransferResponse.put("HomeDirectoryDetails", logicalDetails);

            // 返回 200 OK 和序列化后的 JSON
            return new APIGatewayProxyResponseEvent()
                    .withStatusCode(200)
                    .withBody(objectMapper.writeValueAsString(awsTransferResponse));

        } catch (Exception e) {
            logger.log("Fatal error in SFTP auth flow: " + e.getMessage());
            return createForbiddenResponse();
        }
    }

    // 辅助方法：忽略大小写获取 Header
    private String getHeaderIgnoreCase(Map<String, String> headers, String key) {
        if (headers == null) return null;
        for (Map.Entry<String, String> entry : headers.entrySet()) {
            if (entry.getKey().equalsIgnoreCase(key)) {
                return entry.getValue();
            }
        }
        return null;
    }

    // 辅助方法：统一返回 403 拒绝访问
    private APIGatewayProxyResponseEvent createForbiddenResponse() {
        return new APIGatewayProxyResponseEvent()
                .withStatusCode(403)
                .withBody("{}");
    }
}

三、 部署与架构注意事项
采用纯 Java 原生 Lambda 后，你的架构变得非常轻盈，但有几个关键点需要在你的 Design Doc 中体现：
 * AWS Lambda 控制台配置：
   * Handler 路径必须配置为： com.example.sftp.SftpNativeHandler::handleRequest。
   * 内存配置： 既然不用 Spring Boot，内存配置可以大幅下调至 256 MB 或 512 MB，冷启动依然能在毫秒级完成，这会帮你省下大量 AWS 账单。
 * 环境变量 (Environment Variables)：
   * 不要在代码里写死 Auth Server 和 DaaS 的 URL。利用 Lambda 的环境变量注入 AUTH_SERVER_URL 和 DAAS_APP_URL，这样同一套代码就可以在 Dev/QA/Prod 环境无缝晋级。
 * 异常静默 (Fail-Safe)：
   * 看代码结尾处的 createForbiddenResponse()。当内部报错时，绝对不要返回 500 或者把 Java 的 Exception Stack Trace 返回给 API Gateway。AWS Transfer Family 只认状态码，返回 403 能确保干净利落地掐断非法连接。
