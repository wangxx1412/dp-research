在 AWS Lambda 环境下，不用 WebClient 不仅完全没问题，甚至可能是一个更好的选择。
如果你在 Lambda 中使用 WebClient，通常会在最后加上 .block() 来等待结果。这实际上是将非阻塞（Non-blocking）的响应式编程强行转换为同步阻塞（Synchronous blocking）调用。
1. 不用 WebClient 的影响（利与弊）
正面影响（在 Lambda 环境下是巨大的优势）：
 * 大幅降低冷启动时间 (Cold Start)： WebClient 依赖 spring-boot-starter-webflux，底层引入了 Netty 服务器和 Reactor 框架。这些框架初始化非常重。去掉它们，你的 JAR 包体积会变小，Spring 容器启动速度会显著提升。
 * 更贴合 Lambda 的计费与执行模型： AWS Lambda 的生命周期本身就是事件驱动且单线程隔离的（一个请求分配一个执行环境）。在单线程里搞复杂的 Netty Event Loop 并没有带来高并发的优势，反而增加了 CPU 上下文切换的开销。
 * 更简单的调试与堆栈： 响应式编程（Reactor）的报错堆栈通常深不见底，非常难以排查。同步调用的堆栈则清晰明了。
负面影响：
 * 失去了底层并发发起多个 HTTP 请求的能力（例如同时查两个 App 的接口，然后合并结果）。但根据你的业务流（先拿 Token -> 再拿 Policy），这是一个严格串行的过程，所以完全不需要并发。
2. 替代方案：如何写？
如果你使用的是 Spring Boot 3.2 及以上版本，强烈推荐使用全新的 RestClient。它是 RestTemplate 的现代化替代品，拥有像 WebClient 一样优雅的流式 API (Fluent API)，但底层是纯同步的，无需引入 WebFlux/Netty。
以下是使用 RestClient 重写完整流程的代码：
A. 引入依赖 (pom.xml)
你只需要标准的 Web 依赖即可，不需要 WebFlux。
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>

B. 配置类 (RestClientConfig.java)
我们需要配置超时时间。这在 Lambda 中依然非常重要。这里我们直接使用 Java 11+ 原生的 HttpClient 作为底层引擎，它极其轻量。
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.JdkClientHttpRequestFactory;
import org.springframework.web.client.RestClient;

import java.net.http.HttpClient;
import java.time.Duration;

@Configuration
public class RestClientConfig {

    @Value("${app.api.base-url}")
    private String apiBaseUrl;

    @Bean
    public RestClient appRestClient() {
        // 1. 配置原生的 Java HttpClient (极轻量，适合 Lambda)
        HttpClient nativeClient = HttpClient.newBuilder()
                .connectTimeout(Duration.ofSeconds(5)) // 连接超时
                .build();

        // 2. 包装为 Spring 的 RequestFactory 并设置读取超时
        JdkClientHttpRequestFactory requestFactory = new JdkClientHttpRequestFactory(nativeClient);
        requestFactory.setReadTimeout(Duration.ofSeconds(10)); // 等待响应超时

        // 3. 构建并返回 RestClient
        return RestClient.builder()
                .baseUrl(apiBaseUrl)
                .requestFactory(requestFactory)
                .defaultHeader("Accept", "application/json")
                .build();
    }
}

C. 核心适配器逻辑 (SftpAdapterService.java)
代码风格与 WebClient 几乎一模一样，但去掉了 .bodyToMono() 和 .block()，变成了直接返回对象的同步代码。
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestClient;
import org.springframework.web.client.RestClientResponseException;

import java.util.HashMap;
import java.util.Map;

@Service
public class SftpAdapterService {

    private final RestClient appRestClient;

    public SftpAdapterService(RestClient appRestClient) {
        this.appRestClient = appRestClient;
    }

    public Map<String, Object> processLogin(String username, String password) {

        try {
            // --- Step 1: 去 App 拿 Token ---
            AppTokenResponse tokenResp = appRestClient.post()
                    .uri("/oauth/token")
                    .contentType(MediaType.APPLICATION_JSON)
                    .body(Map.of(
                            "grant_type", "password",
                            "username", username,
                            "password", password,
                            "scope", "sftp.config.read"
                    ))
                    .retrieve()
                    // 直接转化为实体类，无需 block()
                    .body(AppTokenResponse.class); 

            if (tokenResp == null || tokenResp.accessToken() == null) {
                throw new RuntimeException("Authentication succeeded but token is missing");
            }

            // --- Step 2: 拿着 Token 去 App 拿 S3 配置 ---
            AppUserSftpConfig userConfig = appRestClient.get()
                    .uri("/api/user/sftp-config")
                    .header("Authorization", "Bearer " + tokenResp.accessToken())
                    .retrieve()
                    .body(AppUserSftpConfig.class);

            if (userConfig == null) {
                throw new RuntimeException("Failed to retrieve SFTP configuration for user");
            }

            // --- Step 3: 组装 AWS Transfer Family 响应 ---
            return buildAwsResponse(userConfig);

        } catch (RestClientResponseException e) {
            // [CUSTOM] 优雅捕获 4xx 和 5xx 错误
            // e.getResponseBodyAsString() 可以获取 App 返回的详细错误 JSON
            System.err.println("App returned error status: " + e.getStatusCode());
            throw new RuntimeException("Adapter failed during App API call", e);
        }
    }

    private Map<String, Object> buildAwsResponse(AppUserSftpConfig config) {
        Map<String, Object> response = new HashMap<>();
        response.put("Role", config.iamRoleArn());
        
        if (config.scopeDownPolicy() != null) {
            response.put("Policy", config.scopeDownPolicy());
        }

        // [CUSTOM] 强制使用逻辑目录
        response.put("HomeDirectoryType", "LOGICAL");
        response.put("HomeDirectoryDetails", 
            String.format("[{\"Entry\": \"/\", \"Target\": \"%s\"}]", config.s3BucketPath()));

        return response;
    }
}

总结建议
将 WebClient 换成 RestClient 是架构上的一次“减负”。对于 Lambda 这种按毫秒计费、对启动时间极度敏感的计算资源，代码越同步、依赖越少，性能反而越好。
如果你还在使用 Spring Boot 3.0 以下的版本（没有 RestClient），你可以直接使用经典的 RestTemplate，写法上会略微繁琐一点（需要构造 HttpEntity），但底层优化逻辑是相同的。
你接下来的开发环境是 Spring Boot 3.x 吗？需要我提供如果是旧版 Spring Boot 下的 RestTemplate 对应写法吗？


AppUserSftpConfig 是你的后端 App（即拥有用户业务数据的目标系统）在验证了 Access Token 后，返回给 Lambda 适配器的 JSON 数据模型。
它定义了这个特定用户登录 SFTP 后，能在 AWS S3 里做什么、看到什么。
在这里，我们推荐使用 Java 14+ 引入的 record 来定义它，这非常适合这种纯粹的 DTO（数据传输对象）。
1. Java DTO 定义 (Record)
import com.fasterxml.jackson.annotation.JsonProperty;

public record AppUserSftpConfig(
    
    // 1. 必填：该用户在 AWS 侧需要扮演的 IAM Role
    @JsonProperty("iam_role_arn") 
    String iamRoleArn,

    // 2. 必填：该用户在 S3 中对应的专属文件夹路径（物理路径）
    @JsonProperty("s3_bucket_path") 
    String s3BucketPath,

    // 3. 选填：用于进一步限制权限的 Scope-Down Policy (必须是 JSON 格式的字符串)
    @JsonProperty("scope_down_policy") 
    String scopeDownPolicy
) {}

2. 目标 App 返回的真实 JSON 示例 (The Payload)
当你的 Lambda 带着 Token 调用目标 App 的 /api/user/sftp-config 接口时，目标 App 应该返回类似这样的 JSON：
{
  "iam_role_arn": "arn:aws:iam::123456789012:role/BaseSftpAccessRole",
  "s3_bucket_path": "/my-company-data-bucket/departments/engineering/jdoe",
  "scope_down_policy": "{\"Version\":\"2012-10-17\",\"Statement\":[{\"Sid\":\"AllowReadWrite\",\"Effect\":\"Allow\",\"Action\":[\"s3:PutObject\",\"s3:GetObject\",\"s3:DeleteObject\"],\"Resource\":\"arn:aws:s3:::my-company-data-bucket/departments/engineering/jdoe/*\"}]}"
}

3. 关键字段与“坑点”解析
作为负责设计的工程师，在让目标 App 团队开发这个接口时，你需要向他们强调以下几个要点：
A. s3_bucket_path (物理路径映射)
 * 注意： 这个路径是 S3 里的真实物理路径。
 * Lambda 的处理： Lambda 拿到这个路径后，会把它包装成 AWS Transfer Family 要求的 LOGICAL (逻辑目录) 格式。
 * 效果： 用户登录 SFTP 后，只会看到一个根目录 /，但实际上他们所有的操作都被限定在这个 s3_bucket_path 里。
B. scope_down_policy (著名的嵌套 JSON 坑)
 * 大坑预警： 注意看上面 JSON 示例里的 scope_down_policy 的值。它不是一个 JSON 对象 (Object)，而是一个转义后的 JSON 字符串 (Escaped String)。
 * 为什么这样做？ 因为 AWS Transfer Family 的 API 契约要求 Policy 字段必须是 String 类型。如果你的目标 App 直接返回一个 JSON Object，Spring 的 RestClient 在反序列化时会报错，或者后续传给 AWS 时格式不对。
 * 业务意义： iam_role_arn 通常给的是一个范围很大的基础权限（比如允许访问整个 Bucket），而 scope_down_policy 就像一个“紧箍咒”，把它实时缩小到了用户自己的文件夹。
在你的 Design Ticket 中的描述建议
你可以直接把这段描述加进 Ticket 中，明确你对后端 App 的依赖：
> Dependency on Backend App:
> To successfully map the OAuth user to AWS resources, the Backend App must expose an endpoint (e.g., GET /api/user/sftp-config) that returns the AppUserSftpConfig payload. The scope_down_policy field must be an escaped JSON string compliant with AWS IAM syntax to ensure proper dynamic privilege restriction.
> 
